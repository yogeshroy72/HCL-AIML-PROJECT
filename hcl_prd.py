# -*- coding: utf-8 -*-
"""HCL PRD

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18n0DecjXFECftuFGLHYQ8DqNd4Ola_Jk
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install optuna

# STEP 1: IMPORT LIBRARIES
# -------------------------------
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, roc_auc_score, roc_curve, r2_score
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
import optuna

# STEP 2: LOAD DATA
# -------------------------------
from google.colab import drive
drive.mount('/content/drive')

file_path = '/content/drive/MyDrive/ehrs.csv'
df = pd.read_csv(file_path)

# STEP 3: PREPROCESSING
# -------------------------------

# Split BloodPressure
df[['SystolicBP', 'DiastolicBP']] = df['BloodPressure'].str.split('/', expand=True)
df['SystolicBP'] = pd.to_numeric(df['SystolicBP'], errors='coerce')
df['DiastolicBP'] = pd.to_numeric(df['DiastolicBP'], errors='coerce')

# Drop unnecessary columns
df = df.drop(['PatientID', 'Name', 'ContactNumber', 'BloodPressure'], axis=1)

# Fill missing surgeries
df['Surgeries'] = df['Surgeries'].fillna('None')

# Encode categorical columns
categorical_cols = ['Gender', 'PastIllnesses', 'Surgeries', 'FamilyHistory',
                    'BloodTestResults', 'ImagingReports', 'OtherDiagnostics',
                    'ExerciseRoutine', 'DietType', 'SleepPattern']

for col in categorical_cols:
    le = LabelEncoder()
    df[col] = le.fit_transform(df[col])

# Convert numeric columns
df['Temperature(C)'] = pd.to_numeric(df['Temperature(C)'], errors='coerce')
df['HeartRate(bpm)'] = pd.to_numeric(df['HeartRate(bpm)'], errors='coerce')
df['OxygenSaturation(%)'] = pd.to_numeric(df['OxygenSaturation(%)'], errors='coerce')

# Create target variable
df['DiabetesRisk'] = (df['PastIllnesses'] == 1).astype(int)

# Features and labels
X = df.drop('DiabetesRisk', axis=1)
y = df['DiabetesRisk']

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Scale features
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# STEP 4: OPTUNA HYPERPARAMETER TUNING
# -------------------------------

def objective_rf(trial):
    n_estimators = trial.suggest_int('n_estimators', 50, 300)
    max_depth = trial.suggest_int('max_depth', 2, 20)
    min_samples_split = trial.suggest_int('min_samples_split', 2, 10)
    min_samples_leaf = trial.suggest_int('min_samples_leaf', 1, 10)

    model = RandomForestClassifier(
        n_estimators=n_estimators,
        max_depth=max_depth,
        min_samples_split=min_samples_split,
        min_samples_leaf=min_samples_leaf,
        random_state=42
    )
    model.fit(X_train, y_train)
    preds = model.predict(X_test)
    accuracy = accuracy_score(y_test, preds)
    return accuracy

study_rf = optuna.create_study(direction='maximize')
study_rf.optimize(objective_rf, n_trials=20)

print("Best Random Forest Params:", study_rf.best_params)

# Train the best Random Forest model
best_rf = RandomForestClassifier(
    n_estimators=study_rf.best_params['n_estimators'],
    max_depth=study_rf.best_params['max_depth'],
    min_samples_split=study_rf.best_params['min_samples_split'],
    min_samples_leaf=study_rf.best_params['min_samples_leaf'],
    random_state=42
)
best_rf.fit(X_train, y_train)

# STEP 5: MODEL EVALUATION
# -------------------------------

y_pred = best_rf.predict(X_test)
y_proba = best_rf.predict_proba(X_test)[:,1]

acc = accuracy_score(y_test, y_pred)
r2 = r2_score(y_test, y_pred)  # Even though R2 is mainly for regression

print(f"\nAccuracy: {acc:.4f}")
print(f"R2 Score: {r2:.4f}")

# Confusion Matrix
cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.title('Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.show()

# ROC Curve
fpr, tpr, thresholds = roc_curve(y_test, y_proba)
roc_auc = roc_auc_score(y_test, y_proba)

plt.figure()
plt.plot(fpr, tpr, label=f'ROC curve (area = {roc_auc:.2f})')
plt.plot([0,1],[0,1],'r--')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve')
plt.legend()
plt.show()

import joblib

# Load model and scaler from correct path
model = joblib.load('/content/drive/MyDrive/diabetes_model.pkl')
scaler = joblib.load('/content/drive/MyDrive/scaler.pkl')

# Example patient input (manually created)
import pandas as pd

patient_data = {
    'Age': [65],
    'Gender': [1],  # Encoded value
    'PastIllnesses': [2],  # Encoded value
    'Surgeries': [0],  # Encoded value
    'FamilyHistory': [1],  # Encoded value
    'BloodTestResults': [0],
    'ImagingReports': [0],
    'OtherDiagnostics': [0],
    'Temperature(C)': [36.6],
    'HeartRate(bpm)': [72],
    'OxygenSaturation(%)': [96],
    'ExerciseRoutine': [1],
    'DietType': [2],
    'SleepPattern': [1],
    'SystolicBP': [120],
    'DiastolicBP': [80]
}

# Convert to DataFrame
patient_df = pd.DataFrame(patient_data)

# Scale the patient data
patient_scaled = scaler.transform(patient_df)

# Make prediction
prediction = model.predict(patient_scaled)
prediction_proba = model.predict_proba(patient_scaled)

# Show results
if prediction[0] == 1:
    print("‚ö†Ô∏è High risk of Diabetes detected!")
else:
    print("‚úÖ No significant risk of Diabetes.")

print(f"Probability of Diabetes: {prediction_proba[0][1]:.2f}")

!pip install gradio

pip install gradio

import gradio as gr
import pandas as pd
import joblib

# Encoding mappings
gender_map = {'Male':0, 'Female':1, 'Other':2}
illness_map = {'None':0, 'Cancer':1, 'Hypertension':2, 'Other':3}
surgeries_map = {'None':0, 'Appendectomy':1, 'Bypass':2, 'Other':3}
familyhistory_map = {'No':0, 'Yes':1}
test_report_map = {'Normal':0, 'Abnormal':1}
exercise_map = {'Sedentary':0, 'Active':1}
diet_map = {'Balanced':0, 'Low-carb':1, 'High-protein':2}
sleep_map = {'<5 hours':0, '5-7 hours':1, '>7 hours':2}

def predict_diabetes_risk(
    Age, Gender, PastIllnesses, Surgeries, FamilyHistory,
    BloodTestResults, ImagingReports, OtherDiagnostics,
    Temperature, HeartRate, OxygenSaturation, ExerciseRoutine,
    DietType, SleepPattern, SystolicBP, DiastolicBP
):
    # Create input dataframe
    input_data = pd.DataFrame({
        'Age': [Age],
        'Gender': [gender_map[Gender]],
        'PastIllnesses': [illness_map[PastIllnesses]],
        'Surgeries': [surgeries_map[Surgeries]],
        'FamilyHistory': [familyhistory_map[FamilyHistory]],
        'BloodTestResults': [test_report_map[BloodTestResults]],
        'ImagingReports': [test_report_map[ImagingReports]],
        'OtherDiagnostics': [test_report_map[OtherDiagnostics]],
        'Temperature(C)': [Temperature],
        'HeartRate(bpm)': [HeartRate],
        'OxygenSaturation(%)': [OxygenSaturation],
        'ExerciseRoutine': [exercise_map[ExerciseRoutine]],
        'DietType': [diet_map[DietType]],
        'SleepPattern': [sleep_map[SleepPattern]],
        'SystolicBP': [SystolicBP],
        'DiastolicBP': [DiastolicBP]
    })

    # Scale features
    scaled_input = scaler.transform(input_data)

    # Make prediction
    pred = model.predict(scaled_input)
    pred_proba = model.predict_proba(scaled_input)

    # Format output
    risk = "‚ö†Ô∏è High risk of Diabetes detected!" if pred[0] == 1 else "‚úÖ No significant risk of Diabetes."
    probability = f"Probability of Diabetes: {pred_proba[0][1]*100:.2f}%"

    return risk, probability

# Create input components
inputs = [
    gr.Number(label="Age"),
    gr.Dropdown(["Male", "Female", "Other"], label="Gender"),
    gr.Dropdown(["None", "Cancer", "Hypertension", "Other"], label="Past Illnesses"),
    gr.Dropdown(["None", "Appendectomy", "Bypass", "Other"], label="Surgeries"),
    gr.Dropdown(["No", "Yes"], label="Family History of Diabetes?"),
    gr.Dropdown(["Normal", "Abnormal"], label="Blood Test Results"),
    gr.Dropdown(["Normal", "Abnormal"], label="Imaging Reports"),
    gr.Dropdown(["Normal", "Abnormal"], label="Other Diagnostics"),
    gr.Number(label="Temperature (¬∞C)", value=36.6),
    gr.Number(label="Heart Rate (bpm)", value=70),
    gr.Number(label="Oxygen Saturation (%)", value=95),
    gr.Dropdown(["Sedentary", "Active"], label="Exercise Routine"),
    gr.Dropdown(["Balanced", "Low-carb", "High-protein"], label="Diet Type"),
    gr.Dropdown(["<5 hours", "5-7 hours", ">7 hours"], label="Sleep Pattern"),
    gr.Number(label="Systolic Blood Pressure", value=120),
    gr.Number(label="Diastolic Blood Pressure", value=80),
]

# Create output components
outputs = [
    gr.Textbox(label="Risk Assessment"),
    gr.Textbox(label="Probability")
]

# Create interface
demo = gr.Interface(
    fn=predict_diabetes_risk,
    inputs=inputs,
    outputs=outputs,
    title="ü©∫ Diabetes Risk Prediction",
    description="Predict diabetes risk based on patient health data",
    allow_flagging="never"
)

# Launch the app
demo.launch()

import gradio as gr

def my_function(inputs):
    # Your function logic
    return outputs

# Updated interface with flagging_mode
iface = gr.Interface(
    fn=my_function,
    inputs=...,
    outputs=...,
    flagging_mode="auto"  # Instead of allow_flagging
)

iface.launch(
    share=False,  # Disable auto-sharing (optional)
    debug=True    # Enable Colab error logs
)

import gradio as gr

# Example function
def greet(name):
    return f"Hello {name}!"

# Create interface with proper inputs/outputs
iface = gr.Interface(
    fn=greet,
    inputs=gr.Textbox(label="Your name"),  # Valid input component
    outputs=gr.Textbox(label="Greeting"),  # Valid output component
    flagging_mode="auto"
)

iface.launch()